const Product = require('../models/product');
const Supplier = require('../models/supplier');
const PurchaseOrder = require('../models/purchaseorder');
const SalesOrder = require('../models/salesorder');
const StockMovement = require('../models/stockmovement');
const StockLevel = require('../models/stocklevel');
const User = require('../models/user');
const mongoose = require('mongoose');

const getAccessibleUserIds = async (role, userId) => {
  if (role === 'admin') {
    return null;
  }
  
  if (role === 'manager') {
    const user = await User.findById(userId).select('assignedUsers');
    const assignedUsers = user?.assignedUsers || [];
    return [userId, ...assignedUsers.map(id => id.toString())];
  }
  
  return [userId];
};

const buildFilter = (organizationId, role, userIds, fieldName = 'createdBy') => {
  const filter = { organizationId: new mongoose.Types.ObjectId(organizationId) };
  
  if (role !== 'admin' && userIds) {
    filter[fieldName] = { $in: userIds.map(id => new mongoose.Types.ObjectId(id)) };
  }
  
  return filter;
};

exports.getDashboardSummary = async (user, organizationId) => {
  try {
    const userIds = await getAccessibleUserIds(user.role, user.userid);
    
    const productFilter = { organizationId: new mongoose.Types.ObjectId(organizationId) };
    const supplierFilter = { organizationId: new mongoose.Types.ObjectId(organizationId) };
    const purchaseFilter = buildFilter(organizationId, user.role, userIds, 'createdBy');
    const movementFilter = buildFilter(organizationId, user.role, userIds, 'user');
    const stockFilter = { organizationId: new mongoose.Types.ObjectId(organizationId) };

    const [
      totalProducts,
      totalSuppliers,
      purchaseAmount,
      stockQty,
      lowStockItems,
      stockInToday,
      stockOutToday,
      pendingPurchases,
      approvedPurchases
    ] = await Promise.all([
      Product.countDocuments(productFilter),
      Supplier.countDocuments(supplierFilter),
      
      PurchaseOrder.aggregate([
        { $match: { ...purchaseFilter, status: { $in: ["APPROVED", "RECEIVED"] } } },
        { $group: { _id: null, total: { $sum: "$totalamount" } } }
      ]),
      
      StockLevel.aggregate([
        { $match: stockFilter },
        { $group: { _id: null, qty: { $sum: "$quantity" } } }
      ]),
      
      StockLevel.aggregate([
        { $match: stockFilter },
        { $lookup: { from: 'products', localField: 'product', foreignField: '_id', as: 'productInfo' } },
        { $lookup: { from: 'warehouses', localField: 'warehouse', foreignField: '_id', as: 'warehouseInfo' } },
        { $match: { $expr: { $and: [{ $gt: ["$minStock", 0] }, { $lte: ["$quantity", "$minStock"] }] } } },
        { $project: { 
          productId: "$product", 
          productName: { $arrayElemAt: ["$productInfo.name", 0] }, 
          sku: { $arrayElemAt: ["$productInfo.sku", 0] }, 
          warehouseName: { $arrayElemAt: ["$warehouseInfo.name", 0] }, 
          availableQty: "$quantity", 
          minStock: "$minStock" 
        }}
      ]),
      
      StockMovement.aggregate([
        { $match: { 
          ...movementFilter, 
          type: 'IN',
          createdAt: { 
            $gte: new Date(new Date().setHours(0, 0, 0, 0)),
            $lt: new Date(new Date().setHours(23, 59, 59, 999))
          }
        }},
        { $group: { _id: null, qty: { $sum: '$quantity' } } }
      ]),
      
      StockMovement.aggregate([
        { $match: { 
          ...movementFilter, 
          type: 'OUT',
          createdAt: { 
            $gte: new Date(new Date().setHours(0, 0, 0, 0)),
            $lt: new Date(new Date().setHours(23, 59, 59, 999))
          }
        }},
        { $group: { _id: null, qty: { $sum: '$quantity' } } }
      ]),
      
      PurchaseOrder.countDocuments({ ...purchaseFilter, status: 'PENDING' }),
      PurchaseOrder.countDocuments({ ...purchaseFilter, status: 'APPROVED' })
    ]);

    return {
      kpis: {
        totalProducts: totalProducts || 0,
        totalSuppliers: totalSuppliers || 0,
        totalStockQty: stockQty[0]?.qty || 0,
        totalPurchaseAmount: purchaseAmount[0]?.total || 0
      },
      alerts: {
        lowStockCount: lowStockItems.length || 0,
        lowStockItems: lowStockItems || []
      },
      widgets: {
        pendingPurchases: pendingPurchases || 0,
        approvedPurchases: approvedPurchases || 0,
        stockInToday: stockInToday[0]?.qty || 0,
        stockOutToday: stockOutToday[0]?.qty || 0
      }
    };
  } catch (error) {
    console.error('Dashboard error:', error);
    throw error;
  }
};

exports.getStockTrend = async (days = 30, user, organizationId) => {
  try {
    const userIds = await getAccessibleUserIds(user.role, user.userid);
    const movementFilter = buildFilter(organizationId, user.role, userIds, 'user');
    
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);
    startDate.setHours(0, 0, 0, 0);

    const stockTrend = await StockMovement.aggregate([
      { $match: { ...movementFilter, createdAt: { $gte: startDate } } },
      { 
        $group: { 
          _id: { $dateToString: { format: "%Y-%m-%d", date: "$createdAt" } }, 
          inQty: { $sum: { $cond: [{ $eq: ["$type", "IN"] }, "$quantity", 0] } }, 
          outQty: { $sum: { $cond: [{ $eq: ["$type", "OUT"] }, "$quantity", 0] } } 
        } 
      },
      { $sort: { "_id": 1 } },
      { $project: { date: "$_id", inQty: 1, outQty: 1, _id: 0 } }
    ]);

    return stockTrend;
  } catch (error) {
    console.error('Stock trend error:', error);
    throw error;
  }
};

exports.getPurchaseTrend = async (days = 30, user, organizationId) => {
  try {
    const userIds = await getAccessibleUserIds(user.role, user.userid);
    const purchaseFilter = buildFilter(organizationId, user.role, userIds, 'createdBy');
    
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);
    startDate.setHours(0, 0, 0, 0);

    const purchaseTrend = await PurchaseOrder.aggregate([
      { $match: { ...purchaseFilter, createdAt: { $gte: startDate } } },
      { $unwind: "$items" },
      { 
        $group: { 
          _id: { $dateToString: { format: "%Y-%m-%d", date: "$createdAt" } }, 
          totalAmount: { $sum: "$totalamount" }, 
          totalQuantity: { $sum: "$items.quantity" }, 
          count: { $sum: 1 } 
        } 
      },
      { $sort: { "_id": 1 } },
      { $project: { date: "$_id", totalAmount: 1, totalQuantity: 1, count: 1, _id: 0 } }
    ]);

    return purchaseTrend;
  } catch (error) {
    console.error('Purchase trend error:', error);
    throw error;
  }
};

exports.getSalesTrend = async (days = 30, user, organizationId) => {
  try {
    const userIds = await getAccessibleUserIds(user.role, user.userid);
    const salesFilter = buildFilter(organizationId, user.role, userIds, 'user');
    
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);
    startDate.setHours(0, 0, 0, 0);

    const salesTrend = await SalesOrder.aggregate([
      { $match: { ...salesFilter, createdAt: { $gte: startDate } } },
      { 
        $group: { 
          _id: { $dateToString: { format: "%Y-%m-%d", date: "$createdAt" } }, 
          totalRevenue: { $sum: "$totalamount" }, 
          totalOrders: { $sum: 1 } 
        } 
      },
      { $sort: { "_id": 1 } },
      { $project: { date: "$_id", totalRevenue: 1, totalOrders: 1, _id: 0 } }
    ]);

    return salesTrend;
  } catch (error) {
    console.error('Sales trend error:', error);
    throw error;
  }
};
